---
title: "What Does Daemon Do？"
date: 2019-05-11T15:45:20+08:00
draft: false
---

pouch daemon 位于daemon这个包内。

pouch daemon是pouch的守护进程，这里也可以看出，daemon 由crtd(containerd)、container、image、volume、network、server等部分组成。

根据上篇文章分析，在main函数里构建了一个 main.go 运行了 `d := daemon.NewDaemon(cfg)` 返回 daemon 对象。在 传入进去的 `cfg` 是flag的一些配置参数。NewDaemon 位于 daemon/daemon.go#NewDaemon 中。


```golang
type Daemon struct {
	config         *config.Config
	containerStore *meta.Store

	// ctrdDaemon controls containerd process
	ctrdDaemon *supervisord.Daemon

	// ctrdClient is grpc client connecting to the containerd
	ctrdClient ctrd.APIClient

	containerMgr    mgr.ContainerMgr
	systemMgr       mgr.SystemMgr
	imageMgr        mgr.ImageMgr
	volumeMgr       mgr.VolumeMgr
	networkMgr      mgr.NetworkMgr
	server          server.Server
	containerPlugin hookplugins.ContainerPlugin
	imagePlugin     hookplugins.ImagePlugin
	daemonPlugin    hookplugins.DaemonPlugin
	volumePlugin    hookplugins.VolumePlugin
	criPlugin       hookplugins.CriPlugin
	apiPlugin       hookplugins.APIPlugin
	eventsService   *events.Events
}
```	

## NewDaemon 函数

NewDaemon 函数传入是 config 参数（来自于flag命令行） 返回时 daemon 结构体。结构图字段参见上。

第一步：构建containerStore对象。

containerStort 用于保存容器启动、终止（未删除）的信息。

![hello-world-contaner-store](../hello-world-container.png)

这里保存着容器的基本信息，包括hostname、host（记录本地域名解析）、json.log（保存容器的日志信息）、meta.json（保存容器的基本信息，pouch inspect 命令可以查看到）、resolv.conf（保存dns服务器地址）。当删除这个容器，这些信息也会跟着删除。

containerStort的结构如下

```golang
type Store struct {
	Config
	trieLock *sync.Mutex // trieLock use to protect 'trie'.
	trie     *patricia.Trie
	current  *Bucket
	backend  Backend
}

type Config struct {
	Driver  string
	Buckets []Bucket
	BaseDir string
}
```
这里创建containerStore 保存着 存储驱动（默认是local）, baseDir（默认是 $homedir/containers） Buckets保存，容器的基本元数据信息。如下：

```
containerStore, err := meta.NewStore(meta.Config{
		Driver:  "local",
		BaseDir: path.Join(cfg.HomeDir, "containers"),
		Buckets: []meta.Bucket{
			{
				Name: meta.MetaJSONFile,
				Type: reflect.TypeOf(mgr.Container{}),
			},
		},
	})
```

## 第二步：启动containerd

1、首先将 pouch 的一些关于containerd 参数传给 ctdOpt。如：OOMScoreAdjust、ContainerdAddr（containerd二进制文件路径）。

如果 pouch 开启了日志。daemon 将会设置 containerd 日志级别 ’debug‘ 并接管日志。

随后通过 supervisord 带着设置的参数启动 containerd。 并返回 ctrdDaemon 对象。

同理，创建 ctdClient 对象。

随后，创建snapshotter。
> 创建snapshotter之前，要对其进行检查。检查本地环境是否支持（含有）这种 snapshooter。

这里为什么 pouch 使用了 snapshotter?

> PouchContainer 中没有了 GraphDriver 和 Layer 的概念，新的存储架构里引入了 Snapshotter 和 Snapshot，从而更加拥抱 CNCF 项目 containerd 的架构设计。

> Snapshotter 可以理解为存储驱动，比如 overlay、devicemapper、btrfs 等。Snapshot 为镜像快照，分为两种：一种只读的，即容器镜像的每一层只读数据；一种为可读写的，即容器可读写层，所有容器增量数据都会存储在可读写 Snapshot 中；

> Containerd 中容器和镜像元数据都存储在 boltdb 中，这样的好处是每次服务重启不需要通过读取宿主机文件目录信息来初始化容器和镜像数据，而是只需要初始化 boltdb。

> moby 项目使用的 gragbdriver. pouch 项目使用的是 snapshotter.
最后，返回 daemon 对象。

```golang
return &Daemon{
	config:         cfg,
	ctrdClient:     ctrdClient,
	ctrdDaemon:     ctrdDaemon,
	containerStore: containerStore,
}
```



## loadPlugin函数里

main函数里获取了daemon对象后，创建一个携程运行 daemon 的 run 函数。 函数位于 daemon/daemon.go#run。

在 run daemon函数之前，运行 loadPlugin 函数。

loadPlugin函数包含：

- daemonPlugin
- containerPlugin
- imagePlugin
- volumePlugin
- criPlugin
- apiPlugin

虽然 pouch 还有没有实现这些插件，但是可供以后扩展。

## daemon run 函数

加载完成后，
第一步： 初始化运行时
> 初始化运行时创建 runtimes 目录

第二步: 初始化eventsService、imageMgr、systemMgr、volumeMgr、containerMgr、networkMgr 这些顺序不能改变。

### 初始化 imageMgr

初始化 imageMgr 实际上就是创建一个 imageMgr 对象

```golang
func GenSystemMgr(cfg *config.Config, d DaemonProvider) (mgr.SystemMgr, error) {
	return mgr.NewSystemManager(cfg, d.MetaStore(), d.ImgMgr(), d.EventsService())
}
```

images 管理器的结构题如下：
```golang
type ImageManager struct {
	DefaultRegistry string    // 配置默认镜像拉曲仓库

	DefaultNamespace string   // 默认值是 library 

	client ctrd.APIClient     // containerd 客户端

	localStore *imageStore    // 存储 镜像 id name index sha26之类的数据

	eventsService *events.Events

	imagePlugin hookplugins.ImagePlugin
}
```
同理 构建其他管理器的结构体。

> 疑问： 这里为什么会有一个默认值为 'library' 的 default namespce？

containerManager 结构体：

```golang
type ContainerManager struct {

	Store *meta.Store  // 存储 container 运行的信息，默认的驱动是 local，位置在 containers

	Client ctrd.APIClient

	NameToID *collect.SafeMap  // container name to id

	ImageMgr      ImageMgr
	VolumeMgr     VolumeMgr
	NetworkMgr    NetworkMgr
	IOs           *containerio.Cache
	ExecProcesses *collect.SafeMap

	Config *config.Config
	// monitor is used to handle container's event, eg: exit, stop and so on.
	monitor *ContainerMonitor

	containerPlugin hookplugins.ContainerPlugin
	// eventsService is used to publish events generated by pouchd
	eventsService *events.Events
}
```
contaninerManager 创建好后，创建 execProcessGC 的携程。
```golang
go mgr.execProcessGC()
```
它每隔5分钟执行一次，清理没有在运行的容器。

然后 将 meta 里的容器数据加载如内存以获取容器列表

containerMgr.Load(ctx) 

加载得到容器对象列表后，对容器列表进行遍历。
```golang
for _, c := range ctrs {
	endpoint := BuildContainerEndpoint(c)
	sbOptions, err := buildSandboxOptions(cfg.NetworkConfig, endpoint)
	if err != nil {
		return nil, errors.Wrap(err, "failed to build sandbox options")
	}
	cfg.NetworkConfig.ActiveSandboxes[c.NetworkSettings.SandboxID] = sbOptions
}
```

（1）、遍历过程中首先创建 `BuildContainerEndpoint`  返回 network Endpoint 结构体如下：

```golang
type Endpoint struct {
	Name  string
	ID    string
	Owner string

	Hostname       strfmt.Hostname
	Domainname     string
	HostnamePath   string
	HostsPath      string
	ExtraHosts     []string
	ResolvConfPath string
	DNS            []string
	DNSOptions     []string
	DNSSearch      []string

	NetworkDisabled bool
	NetworkMode     string
	MacAddress      string
	PublishAllPorts bool
	ExposedPorts    map[string]interface{}
	PortBindings    types.PortMap

	NetworkConfig  *types.NetworkSettings
	EndpointConfig *types.EndpointSettings

	GenericParams   map[string]interface{}
	Priority        int
	DisableResolver bool
}
```
这是容器网络端点。

(2)、接下来加载判断 host hostOption dns dnsSearch port等对象。最终返回网络对象。

## 启动之前处于开启的容器

初始化完成后，容器进行 `Restore` 函数。这个函数重新启动 running 的容器。

启动之前 对容器进行 `initContainerIO` `initLogDriverBeforeStart` 判断。容器状态判断，如果处于挂起状态，则 不进行下去了。

recoverContainer 方法位于 `ctrd/container.go#recoverContainer`

具体的实现方式将来有时间再分析：todo

（3）、给容器打标签

对于每一个容器而言，它也有标签。pouchd 命令传入参数支持打标签。
启动的时候，通过 `addSystemLabels` 函数获取标签。
默认获取 nodeIp 标签，值为宿主机ip、serialNo 标签 值为机器的值。
值的获取方式分别通过 `host -i` 命令 `dmidecode -s system-serial-number` 获取。


（4）、init base Network

初始化网络。先后初始化 none host bridge 类型网络。

（5）、init image proxy


（6）、启动一个携程 运行 criService

（7）、启动一个 http server

后面就是接收各种中断处理。







